<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeSync - Collaborative Video Watch</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load YouTube Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        /* Custom CSS for a soft, inviting couples theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0c0b10; /* Darker, deep purple background */
            color: #f7e0e9; /* Soft rose white text */
        }
        
        /* --- NEW CARD STYLES (FROSTED GLASS EFFECT) --- */
        .vibe-card-setup {
            background: rgba(30, 24, 50, 0.6); /* Slightly transparent dark purple */
            backdrop-filter: blur(8px); /* Frosted glass effect */
            border: 1px solid rgba(130, 100, 180, 0.3); /* Soft, light border */
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 100px rgba(255, 0, 100, 0.15); /* Deep shadow with subtle rose glow */
        }

        .vibe-card {
            background-color: #1a1526; /* Dark slate/indigo card background for main content */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            border: 1px solid #3c325c;
        }

        .vibe-button {
            transition: all 0.2s ease-in-out;
            @apply bg-rose-500 hover:bg-rose-600 active:bg-rose-700 text-white font-semibold py-3 px-6 rounded-xl focus:outline-none focus:ring-4 focus:ring-rose-400 focus:ring-opacity-70 shadow-lg transform hover:scale-[1.02]
        }

        /* Primary Button Style (for Join Room) */
        .vibe-button-primary {
            @apply vibe-button bg-pink-600 hover:bg-pink-700 focus:ring-pink-500 shadow-xl shadow-pink-900/50
        }

        /* Secondary Button Style (for Generate Key) */
        .vibe-button-secondary {
            @apply bg-indigo-600 hover:bg-indigo-700 active:bg-indigo-800 text-white font-semibold py-3 px-6 rounded-xl focus:ring-indigo-400 focus:ring-opacity-70 shadow-md
        }

        .vibe-input {
            /* Input is now larger and uses white text for contrast */
            @apply w-full px-5 py-4 text-2xl text-center rounded-xl bg-white/10 text-rose-100 border border-rose-500/30 focus:ring-2 focus:ring-rose-500 focus:border-rose-500 placeholder-indigo-400 tracking-wider
        }

        /* Custom styles for video feed */
        #localVideo, #remoteVideo {
            width: 100%;
            height: 100%;
            background-color: #333;
            object-fit: cover;
        }
        #youtubePlayer {
            width: 100%;
            aspect-ratio: 16 / 9; /* Standard video aspect ratio */
            background-color: black;
        }
        #localVideoContainer {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            width: 150px;
            height: 100px;
            z-index: 20;
            border: 3px solid #f472b6; /* Rose border */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #localVideoContainer {
                width: 100px;
                height: 75px;
                bottom: 0.5rem;
                right: 0.5rem;
            }
            /* Make the button group stack on mobile for better touch target */
            .responsive-button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 flex flex-col items-center justify-center">

    <!-- Header -->
    <header class="text-center mb-10 mt-4">
        <h1 class="text-5xl font-extrabold text-rose-400 tracking-wider">VibeSync</h1>
        <p class="text-indigo-300 text-xl mt-1">Connect. Watch. Vibe.</p>
    </header>

    <!-- Room Setup Card - REDESIGNED UI -->
    <div id="setup-card" class="vibe-card-setup p-8 rounded-3xl w-full max-w-xl mx-auto mb-8 transition-opacity duration-500">
        <h2 class="text-3xl font-bold mb-8 text-center text-rose-200">
            Enter Your Shared Key
        </h2>
        
        <!-- Key Input Field -->
        <div class="relative mb-8">
            <input type="text" id="roomKey" placeholder="Four-Word Vibe Key" class="vibe-input text-center uppercase" maxlength="20" />
        </div>

        <!-- Button Group (Generate is Secondary, Join is Primary) -->
        <div class="responsive-button-group flex flex-row gap-4 mb-6">
            
            <button id="generateKeyButton" class="vibe-button-secondary flex-grow flex items-center justify-center gap-2">
                <!-- SVG Icon: Magic Wand -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                    <path d="M19 21l-7-7-7 7m7-14L5 3m14 11a5 5 0 01-5-5V3a5 5 0 0110 0v6a5 5 0 01-5 5z"/>
                </svg>
                Generate Key
            </button>
            
            <button id="joinRoomButton" class="vibe-button-primary flex-grow flex items-center justify-center gap-2">
                <!-- SVG Icon: Heart -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 fill-white">
                    <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/>
                </svg>
                Join Vibe
            </button>
        </div>

        <p id="auth-status" class="mt-6 text-center text-sm text-indigo-300">Authenticating connection...</p>
    </div>
    
    <!-- --- -->

    <!-- Main Vibe Sync Area -->
    <div id="vibe-container" class="hidden w-full max-w-5xl">
        <div class="vibe-card rounded-2xl p-4 md:p-6 mb-8 relative">
            <!-- YouTube Player -->
            <div id="youtubePlayer" class="rounded-xl overflow-hidden"></div>

            <!-- Local Video Container (Picture-in-Picture Style) -->
            <div id="localVideoContainer" class="rounded-xl overflow-hidden shadow-2xl">
                <video id="localVideo" autoplay muted playsinline class="rounded-lg"></video>
            </div>

            <!-- Remote Video Container -->
            <video id="remoteVideo" autoplay playsinline class="rounded-xl w-full aspect-video mt-4 hidden"></video>

            <!-- Video Controls - Host Only -->
            <div class="mt-4 flex flex-col md:flex-row gap-4">
                <input type="text" id="youtubeUrlInput" placeholder="Paste YouTube URL (Host Only)" class="vibe-input flex-grow text-base" disabled />
                <button id="setVideoButton" class="vibe-button md:w-auto bg-indigo-500 hover:bg-indigo-600" disabled>Set Video</button>
            </div>
            <p id="host-message" class="text-sm text-indigo-300 mt-2">Only the Host can set a new video, but both can Play/Pause.</p>
        </div>

        <!-- Connection Status -->
        <div class="text-center text-sm mb-4">
            <p id="connection-status" class="text-rose-400 font-medium">Ready to connect to partner.</p>
            <p id="peerIdDisplay" class="text-xs text-indigo-500"></p>
        </div>

        <!-- Call Controls -->
        <div class="flex justify-center gap-4 mb-8">
            <button id="startCallButton" class="vibe-button px-8 py-3 bg-green-600 hover:bg-green-700">Start Video Call</button>
            <button id="hangupButton" class="vibe-button px-8 py-3 bg-red-600 hover:bg-red-700 hidden">End Call</button>
        </div>
    </div>

    <!-- Script Block -->
    <script type="module">
        // --- Global Firebase Variables (Mandatory for Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Firebase Modular SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, orderBy, limit, addDoc, updateDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase logging level to Debug
        setLogLevel('Debug');

        let app, db, auth;
        let userId = null;
        let roomId = null;
        let peerConnection = null;
        let localStream = null;
        let youtubePlayer = null;
        let isHost = false;
        let partnerId = null;

        // WebRTC Configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // --- DOM Elements ---
        const authStatusEl = document.getElementById('auth-status');
        const setupCard = document.getElementById('setup-card');
        const vibeContainer = document.getElementById('vibe-container');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const roomKeyInput = document.getElementById('roomKey');
        const generateKeyButton = document.getElementById('generateKeyButton');
        const youtubeUrlInput = document.getElementById('youtubeUrlInput');
        const setVideoButton = document.getElementById('setVideoButton');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startCallButton = document.getElementById('startCallButton');
        const hangupButton = document.getElementById('hangupButton');
        const connectionStatusEl = document.getElementById('connection-status');
        const peerIdDisplay = document.getElementById('peerIdDisplay');

        // --- Utility Functions ---

        /** Extracts YouTube Video ID from various URL formats. */
        function getYouTubeVideoId(url) {
            const urlRegex = /(?:youtu\.be\/|youtube\.com\/(?:watch\?(?:.*&)?v=|(?:embed|v)\/))([a-zA-Z0-9_-]{11})/;
            const match = url.match(urlRegex);
            return match ? match[1] : null;
        }

        /** Formats Firestore path for a specific room's public data. */
        function getRoomDocRef(id) {
            return doc(db, 'artifacts', appId, 'public', 'data', 'viberoom', id);
        }

        /** Formats Firestore path for a room's signaling collection. */
        function getSignalingCollection(roomId) {
            return collection(db, 'artifacts', appId, 'public', 'data', 'viberoom', roomId, 'signals');
        }

        /** Generates a simple, memorable 4-word room key. */
        function generateRandomKey() {
            const adjectives = ["Crimson", "Golden", "Silent", "Vibrant", "Dreamy", "Cozy", "Sweet", "Aqua", "Lunar", "Solar"];
            const nouns = ["Star", "Vibe", "Cloud", "Fire", "Soul", "Heart", "Gemini", "Echo", "River", "Bloom"];
            const verbs = ["Watch", "Sync", "Chill", "Flow", "Share", "Connect", "Tune", "Listen", "Smile", "Kiss"];
            const adverbs = ["Now", "Always", "Gently", "Close", "Deeply", "Here", "Easy", "Fast", "Soon", "Yet"];
            
            const random = (arr) => arr[Math.floor(Math.random() * arr.length)];
            
            return `${random(adjectives)}${random(nouns)}${random(verbs)}${random(adverbs)}`;
        }


        // --- 1. Firebase Initialization & Authentication ---

        function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Sign in using the custom token if available, otherwise sign in anonymously
                if (initialAuthToken) {
                    signInWithCustomToken(auth, initialAuthToken)
                        .catch(error => {
                            console.error("Custom token sign-in failed, falling back to anonymous:", error);
                            signInAnonymously(auth);
                        });
                } else {
                    signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        authStatusEl.textContent = `Authenticated as: ${userId.substring(0, 8)}...`;
                        peerIdDisplay.textContent = `Your ID: ${userId}`;
                        joinRoomButton.disabled = false;
                        generateKeyButton.disabled = false;
                    } else {
                        userId = null;
                        authStatusEl.textContent = "Authentication failed.";
                        joinRoomButton.disabled = true;
                        generateKeyButton.disabled = true;
                    }
                });

            } catch (e) {
                console.error("Firebase initialization failed:", e);
                authStatusEl.textContent = "Error: Firebase setup failed. Check console.";
            }
        }
        
        // --- 2. Room Joining Logic ---

        generateKeyButton.addEventListener('click', () => {
            roomKeyInput.value = generateRandomKey();
        });

        joinRoomButton.addEventListener('click', () => {
            if (!userId) return;

            const key = roomKeyInput.value.trim();
            if (key.length < 4) {
                console.error('Validation Error: Room key must be at least 4 characters.');
                roomKeyInput.classList.add('border-red-500', 'ring-red-500');
                setTimeout(() => {
                    roomKeyInput.classList.remove('border-red-500', 'ring-red-500');
                }, 1500);
                return;
            }

            roomId = key;
            setupCard.classList.add('hidden');
            vibeContainer.classList.remove('hidden');
            // Ensure the main container is centered after setup card hides
            document.body.classList.remove('justify-center');
            document.body.classList.add('justify-start');


            initializeRoom();
        });

        // --- 3. YouTube Player API Initialization ---

        window.onYouTubeIframeAPIReady = function() {
            youtubePlayer = new YT.Player('youtubePlayer', {
                height: '100%',
                width: '100%',
                videoId: 'dQw4w9WgXcQ', // Default video (Rick Astley - Never Gonna Give You Up)
                playerVars: {
                    'controls': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'showinfo': 0,
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        };

        function onPlayerReady(event) {
            console.log("YouTube Player Ready.");
            // Host starts the periodic sync loop to correct time drift
            if (isHost) {
                setInterval(syncHostVideoTime, 2000); 
            }
        }

        /**
         * Both users can trigger a state change (Play/Pause). 
         * This function sends the action to Firestore for the partner to follow.
         */
        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.PAUSED) {
                sendVideoActionToPartner(event.data);
            }
        }

        // --- 4. Firestore Room and Sync Logic ---

        async function initializeRoom() {
            const roomRef = getRoomDocRef(roomId);
            const roomSnap = await getDoc(roomRef);

            if (roomSnap.exists()) {
                console.log("Joining existing room.");
                isHost = false; // Guest
                // Find host ID for signaling and video control context
                const data = roomSnap.data();
                for (const uid in data.users) {
                    if (data.users[uid].isHost) {
                        partnerId = uid; // Host is my first partner candidate
                        break;
                    }
                }
                
                await setMyRoomStatus(false); 
                connectionStatusEl.textContent = `Joined room '${roomId}'. Waiting for partner.`;
            } else {
                console.log("Creating new room. You are the Host.");
                isHost = true; // Host
                // Create initial room document with default video state
                await setDoc(roomRef, {
                    youtubeUrl: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
                    // latestAction logs the most recent state change (play/pause)
                    latestAction: { state: YT.PlayerState.PAUSED, time: 0, userId: userId, timestamp: Date.now() }, 
                    hostId: userId,
                    // 'users' map is added in setMyRoomStatus
                });
                await setMyRoomStatus(true);
                connectionStatusEl.textContent = `Room '${roomId}' created. You are the Host.`;
                setInterval(syncHostVideoTime, 2000); // Host sync loop
            }

            // Start listening for room state changes (video sync & user status)
            onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    handleRoomStateUpdate(doc.data());
                }
            });
            
            // Set Host-only controls
            youtubeUrlInput.disabled = !isHost;
            setVideoButton.disabled = !isHost;
            if (isHost) {
                setVideoButton.classList.replace('bg-indigo-500', 'bg-rose-500');
            } else {
                setVideoButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        /** Sets the current user's status (Host/Guest, ready: true) in the room doc. */
        async function setMyRoomStatus(isHostStatus) {
            const roomRef = getRoomDocRef(roomId);

            // Use updateDoc to set the current user's specific fields, including ready: true
            await updateDoc(roomRef, {
                [`users.${userId}`]: { 
                    isHost: isHostStatus, 
                    ready: true, 
                    lastSeen: Date.now() 
                }
            });
            console.log(`User status updated: isHost=${isHostStatus}, ready=true.`);
        }

        /** Handles incoming updates from Firestore for both video sync and user status. */
        function handleRoomStateUpdate(data) {
            const newVideoId = getYouTubeVideoId(data.youtubeUrl);
            const currentState = youtubePlayer ? youtubePlayer.getPlayerState() : -1;
            
            // 1. Handle Video URL Change (Host-only action)
            if (youtubePlayer && newVideoId && youtubePlayer.getVideoData().video_id !== newVideoId) {
                console.log("Loading new video:", newVideoId);
                youtubePlayer.loadVideoById(newVideoId);
                // Ensure time starts at 0 for new video
                if (data.latestAction) data.latestAction.time = 0;
            }

            // 2. Handle Shared Play/Pause Sync
            if (data.latestAction && data.latestAction.userId !== userId && youtubePlayer) {
                const targetState = data.latestAction.state; 
                const targetTime = data.latestAction.time;
                const currentTime = youtubePlayer.getCurrentTime();

                if (targetState === YT.PlayerState.PLAYING && currentState !== YT.PlayerState.PLAYING) {
                    youtubePlayer.playVideo();
                } else if (targetState === YT.PlayerState.PAUSED && currentState !== YT.PlayerState.PAUSED) {
                    youtubePlayer.pauseVideo();
                }

                // Correct time drift if needed (more than 1.5 seconds difference)
                if (Math.abs(currentTime - targetTime) > 1.5) {
                    console.log(`Syncing time: Current=${currentTime.toFixed(1)}, Target=${targetTime.toFixed(1)}`);
                    youtubePlayer.seekTo(targetTime, true);
                }
            }

            // 3. Identify partner for WebRTC
            partnerId = null;
            let partnerFound = false;
            // Iterate through all users in the room
            for (const uid in data.users) {
                // Find a user that isn't me AND is marked as ready
                if (uid !== userId && data.users[uid].ready) {
                    partnerId = uid;
                    partnerFound = true;
                    remoteVideo.classList.remove('hidden');
                    startCallButton.classList.remove('hidden');
                    connectionStatusEl.textContent = `Partner ID found: ${partnerId.substring(0, 8)}... Ready to start call.`;
                    break;
                }
            }
            if (!partnerFound) {
                partnerId = null;
                remoteVideo.classList.add('hidden');
                startCallButton.classList.add('hidden');
                connectionStatusEl.textContent = `Waiting for partner in room '${roomId}'.`;
            }
        }

        /** Called by onPlayerStateChange to write a play/pause action to Firestore. */
        function sendVideoActionToPartner(state) {
            if (!roomId || !youtubePlayer) return;

            const roomRef = getRoomDocRef(roomId);
            const currentTime = youtubePlayer.getCurrentTime();

            updateDoc(roomRef, {
                latestAction: {
                    state: state,
                    time: currentTime,
                    userId: userId,
                    timestamp: Date.now()
                }
            }).catch(e => console.error("Error sending video action:", e));
        }


        setVideoButton.addEventListener('click', () => {
            if (!isHost || !youtubePlayer) return;
            const url = youtubeUrlInput.value.trim();
            const newVideoId = getYouTubeVideoId(url);

            if (newVideoId) {
                const roomRef = getRoomDocRef(roomId);
                // Update Firestore, which triggers the onSnapshot listener for both users
                setDoc(roomRef, { youtubeUrl: url }, { merge: true })
                    .then(() => console.log("Video URL updated in Firestore."))
                    .catch(e => console.error("Error setting video URL:", e));
            } else {
                console.error('Validation Error: Invalid YouTube URL.');
                youtubeUrlInput.classList.add('border-red-500', 'ring-red-500');
                setTimeout(() => {
                    youtubeUrlInput.classList.remove('border-red-500', 'ring-red-500');
                }, 1500);
            }
        });

        /** * Host-only function to periodically sync the video time to correct drift.
         * Note: This does NOT overwrite play/pause state anymore, as that is handled by latestAction.
         */
        function syncHostVideoTime() {
            if (!isHost || !youtubePlayer) return;

            const state = youtubePlayer.getPlayerState();
            const isPlaying = state === YT.PlayerState.PLAYING;
            const currentTime = youtubePlayer.getCurrentTime();
            
            // Only update Firestore if the video is currently playing 
            // to minimize writes when both parties are paused.
            if (isPlaying) {
                const roomRef = getRoomDocRef(roomId);
                updateDoc(roomRef, {
                    // This primarily forces time correction for guests.
                    latestAction: {
                        state: state, // Re-enforce the state
                        time: currentTime,
                        userId: userId, // Host is sending this update
                        timestamp: Date.now()
                    }
                }).catch(e => console.error("Error syncing video time:", e));
            }
        }

        // --- 5. WebRTC Signaling and Call Logic ---

        startCallButton.addEventListener('click', () => {
            if (!partnerId) {
                console.error('Call Error: Partner not in room.');
                connectionStatusEl.textContent = 'Cannot start call: Partner not in room.';
                setTimeout(() => {
                    connectionStatusEl.textContent = `Waiting for partner in room '${roomId}'.`;
                }, 3000);
                return;
            }
            startCallButton.classList.add('hidden');
            hangupButton.classList.remove('hidden');
            connectionStatusEl.textContent = 'Starting video call...';
            startWebRTCSession();
        });

        hangupButton.addEventListener('click', () => {
            hangup();
        });

        async function startWebRTCSession() {
            try {
                // 1. Get media stream
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                
                // 2. Create peer connection and add tracks
                peerConnection = new RTCPeerConnection(configuration);
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // 3. Setup event handlers
                peerConnection.ontrack = (event) => {
                    if (remoteVideo.srcObject !== event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        console.log('Received remote stream');
                        remoteVideo.classList.remove('hidden');
                    }
                };
                
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        saveCandidate(event.candidate.toJSON(), userId);
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state change:', peerConnection.connectionState);
                    if (peerConnection.connectionState === 'connected') {
                        connectionStatusEl.textContent = 'WebRTC Connection ESTABLISHED!';
                    } else if (['failed', 'disconnected', 'closed'].includes(peerConnection.connectionState)) {
                        connectionStatusEl.textContent = 'WebRTC Connection FAILED/CLOSED. Hanging up.';
                        hangup();
                    }
                };

                // 4. Determine which role (Offer or Answer) to take
                const signalingRef = getSignalingCollection(roomId);
                const partnerOfferDoc = doc(signalingRef, `${partnerId}-offer`);
                // Using getDoc is a quick check to see if an offer is already pending
                const partnerOfferSnap = await getDoc(partnerOfferDoc);

                if (partnerOfferSnap.exists()) {
                    // Answerer: Partner has already created an offer.
                    await processOffer(partnerOfferSnap.data().sdp);
                    listenForCandidates(partnerId); // Listen for partner's candidates
                    listenForCandidates(userId);   // Listen for own candidates (they might arrive after answer)
                } else {
                    // Offerer: Create and send offer.
                    await createAndSendOffer();
                    listenForCandidates(partnerId); // Listen for partner's candidates
                }

                listenForAnswer(); // Both need to listen for the Answer
            } catch (err) {
                console.error('Error starting WebRTC session:', err);
                connectionStatusEl.textContent = 'Call failed. Check camera/mic permissions.';
                hangupButton.classList.add('hidden');
                startCallButton.classList.remove('hidden');
            }
        }

        // --- Signaling Functions ---

        async function createAndSendOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            const signalingRef = getSignalingCollection(roomId);
            await setDoc(doc(signalingRef, `${userId}-offer`), { sdp: peerConnection.localDescription.sdp, createdAt: Date.now() });
            
            console.log('Offer sent to Firestore.');
            connectionStatusEl.textContent = `Offer sent. Waiting for ${partnerId.substring(0, 8)}... to accept.`;
        }

        async function processOffer(sdp) {
            const offer = new RTCSessionDescription({ type: 'offer', sdp });
            await peerConnection.setRemoteDescription(offer);
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            const signalingRef = getSignalingCollection(roomId);
            await setDoc(doc(signalingRef, `${userId}-answer`), { sdp: peerConnection.localDescription.sdp, createdAt: Date.now() });
            
            console.log('Answer sent to Firestore.');
            connectionStatusEl.textContent = `Answer sent. Waiting for connection.`;
        }

        function listenForAnswer() {
            const signalingRef = getSignalingCollection(roomId);
            onSnapshot(doc(signalingRef, `${partnerId}-answer`), async (docSnap) => {
                if (docSnap.exists() && peerConnection && peerConnection.signalingState !== 'stable') {
                    const answer = docSnap.data().sdp;
                    const remoteDesc = new RTCSessionDescription({ type: 'answer', sdp: answer });
                    await peerConnection.setRemoteDescription(remoteDesc);
                    console.log('Received and set remote answer.');
                }
            });
        }

        async function saveCandidate(candidate, senderId) {
            if (!candidate) return;
            const signalingRef = getSignalingCollection(roomId);
            // Using a subcollection for candidates is robust for real-time signaling
            await addDoc(collection(signalingRef, `${senderId}-candidates`), candidate);
        }

        function listenForCandidates(peerToListen) {
            const signalingRef = getSignalingCollection(roomId);
            onSnapshot(collection(signalingRef, `${peerToListen}-candidates`), (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        if (peerConnection && peerConnection.remoteDescription) {
                            peerConnection.addIceCandidate(candidate).catch(e => console.error('Error adding ICE candidate:', e));
                        } else {
                            // Candidate buffering is typically done here in more complex apps, 
                            // but for a simple case, logging the potential issue is sufficient.
                            console.log('Candidate received before remote description.');
                        }
                    }
                });
            });
        }

        function hangup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            remoteVideo.classList.add('hidden');
            
            connectionStatusEl.textContent = `Call ended. Ready for next connection.`;
            hangupButton.classList.add('hidden');
            startCallButton.classList.remove('hidden');

            // Note: In a production app, you would also clear out the signaling documents here.
        }

        // --- Initialize App on Load ---
        window.addEventListener('load', initFirebase);

    </script>
</body>
</html>
