<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Watch Party with Video Call</title>
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
    <style>
        /* Define Dark Theme Variables */
        :root {
            --color-primary-dark: #12121e; /* Deepest background */
            --color-secondary-dark: #1e1e2d; /* Main content background (container, headers) */
            --color-tertiary-dark: #2a2a3e; /* Elevated surfaces (chat, message input) */
            --color-text-light: #e0e0e0;
            --color-text-muted: #aaaaaa;
            --color-accent-blue: #667eea; /* Vibrant highlight */
            --color-border-dark: #3a3a5a;
            --color-alert-red: #f87171; /* New, softer red for alerts */
            --color-timer-default: #fde047; /* Yellow for good visibility */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--color-primary-dark);
            min-height: 100vh;
            padding: 10px;
            color: var(--color-text-light); /* Default text color */
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--color-secondary-dark); /* Dark container background */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            overflow: hidden;
        }

        .header {
            /* Keep vibrant gradient for header contrast */
            background: linear-gradient(135deg, #4458bc 0%, #683a99 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .room-info {
            background: rgba(255,255,255,0.1); /* Subtle white overlay */
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            /* Flex layout for side-by-side timer/ID */
            display: flex;
            align-items: center;
            gap: 15px; 
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        #roomTimerDisplay {
            font-weight: bold;
            transition: color 0.5s;
            white-space: nowrap;
        }

        /* ------------------------------------- */
        /* MAIN LAYOUT - DEFAULT (Desktop/Wide) */
        /* ------------------------------------- */
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 0;
            height: calc(100vh - 120px); 
        }

        .video-call-section {
            background: #1a1a2e; /* Deep blue/black for video section */
            padding: 20px;
            overflow-y: auto;
        }

        .video-call-header {
            color: white;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .call-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .call-btn {
            flex: 1;
            padding: 10px 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.3s;
            text-align: center;
            color: white; /* Ensure text is visible on dark buttons */
        }

        .call-btn.active {
            background: #4CAF50;
        }

        .call-btn.inactive {
            background: #f44336;
        }

        .call-btn:hover {
            opacity: 0.8;
        }

        .video-grid {
            display: grid;
            gap: 10px;
            grid-template-columns: 1fr;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            aspect-ratio: 4/3;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); /* Subtle shadow on videos */
        }

        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .admin-tag {
            background-color: var(--color-accent-blue); /* Use accent color for admin */
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 10px;
        }

        .video-section {
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            background: var(--color-secondary-dark); /* Matches container background */
        }

        .video-controls {
            display: flex;
            gap: 10px;
        }

        #videoUrlInput {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid var(--color-border-dark); /* Dark border */
            background: var(--color-tertiary-dark); /* Dark input background */
            color: var(--color-text-light); /* Light text */
            border-radius: 10px;
            font-size: 14px;
            transition: border 0.3s;
        }

        #videoUrlInput:focus {
            outline: none;
            border-color: var(--color-accent-blue);
        }

        #loadVideoBtn {
            padding: 12px 30px;
            background: linear-gradient(135deg, var(--color-accent-blue) 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        #loadVideoBtn:hover {
            transform: translateY(-2px);
        }

        /* Video.js player container */
        .video-js {
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 8px 20px rgba(0,0,0,0.7); /* Stronger shadow on the player */
        }
        
        #player {
            width: 100%;
            height: 100%;
        }

        .chat-section {
            background: var(--color-tertiary-dark); /* Slightly lighter dark shade for chat */
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--color-border-dark); /* Dark separator */
        }

        .chat-header {
            padding: 20px;
            background: var(--color-secondary-dark); /* Header matches container */
            border-bottom: 1px solid var(--color-border-dark);
        }

        .chat-header h2 {
            font-size: 20px;
            color: var(--color-text-light);
        }

        .users-online {
            display: flex;
            flex-direction: column; 
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .user-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .user-badge {
            background: var(--color-border-dark); /* Darker badge background */
            color: var(--color-text-light);
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            flex-grow: 1;
        }
        
        .admin-action-btn {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: background 0.2s;
            white-space: nowrap;
        }
        
        .admin-action-btn:hover {
            background: #45a049;
        }

        #messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-user {
            font-weight: 600;
            color: var(--color-accent-blue); /* Accent color for username */
            margin-bottom: 5px;
            font-size: 14px;
        }

        .message-text {
            background: var(--color-border-dark); /* Message bubble background */
            color: var(--color-text-light);
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
            word-wrap: break-word;
        }

        .message-system {
            text-align: center;
            color: var(--color-text-muted); /* Muted grey for system messages */
            font-size: 13px;
            font-style: italic;
        }

        .chat-input {
            padding: 20px;
            background: var(--color-secondary-dark); /* Matches container background */
            border-top: 1px solid var(--color-border-dark);
            display: flex;
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid var(--color-border-dark);
            background: var(--color-tertiary-dark);
            color: var(--color-text-light);
            border-radius: 10px;
            font-size: 14px;
        }

        #messageInput:focus {
            outline: none;
            border-color: var(--color-accent-blue);
        }

        #sendBtn {
            padding: 12px 25px;
            background: var(--color-accent-blue);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        #sendBtn:hover {
            background: #5568d3;
        }
        
        /* Modal Styles - Dark Theme */
        .modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--color-secondary-dark); /* Dark modal background */
            color: var(--color-text-light);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 500px;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: var(--color-text-light);
        }

        .modal-content input {
            width: 100%;
            padding: 12px 20px;
            border: 2px solid var(--color-border-dark);
            background: var(--color-tertiary-dark);
            color: var(--color-text-light);
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        /* Placeholder color for dark inputs */
        .modal-content input::placeholder {
            color: var(--color-text-muted);
            opacity: 1; /* Firefox fix */
        }


        .modal-content button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--color-accent-blue) 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
        }

        .modal-content button:hover {
            opacity: 0.9;
        }

        .acceptance-text {
            text-align: center;
            font-size: 12px;
            color: var(--color-text-muted);
            margin-top: 15px;
        }
        
        .acceptance-text a {
            color: var(--color-accent-blue);
            text-decoration: underline;
            font-weight: 600;
        }

        .hidden {
            display: none;
        }

        /* ------------------------------------- */
        /* WATERMARK STYLES - NEWLY ADDED */
        /* ------------------------------------- */
        .watermark {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4); /* Subtle white on dark background */
            z-index: 999;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            white-space: nowrap; /* Prevent wrapping */
        }
        .watermark a {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s;
        }
        .watermark a:hover {
            color: var(--color-accent-blue);
            text-decoration: underline;
        }

        /* ------------------------------------- */
        /* MEDIA QUERY: Tablet/Laptop (up to 1200px) */
        /* ------------------------------------- */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                height: auto; 
            }

            .video-call-section {
                max-height: 250px;
            }

            .video-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }

            .chat-section {
                border-left: none;
                border-top: 1px solid var(--color-border-dark);
                height: 400px; 
            }
        }

        /* ------------------------------------- */
        /* MEDIA QUERY: Mobile Devices (up to 768px) */
        /* ------------------------------------- */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                border-radius: 10px;
            }

            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
                padding: 15px;
            }
            
            .header h1 {
                font-size: 20px;
            }

            .room-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
                padding: 8px 12px;
            }

            .main-content {
                height: auto;
            }
            
            .video-section {
                padding: 15px;
            }
            
            .video-controls {
                flex-direction: column;
            }
            
            #loadVideoBtn {
                width: 100%;
            }

            .video-call-section {
                max-height: 200px;
            }
            
            .video-grid {
                grid-template-columns: 1fr 1fr;
                gap: 5px;
            }
            
            .video-container {
                aspect-ratio: 1/1;
            }
            
            .chat-section {
                height: 300px;
            }
            
            .chat-input {
                padding: 10px;
            }

            .chat-input button {
                padding: 10px 20px;
            }
            
            /* Smaller watermark on mobile */
            .watermark {
                font-size: 10px;
                bottom: 5px;
                right: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="setupModal" class="modal">
        <div class="modal-content">
            <h2>Join Watch Party v1.4üéâ</h2>
            <input type="text" id="usernameInput" placeholder="Enter your name">
            <input type="text" id="roomIdInput" placeholder="Enter room ID (or leave blank to create)">
            <button id="joinBtn">Join Room</button>
            <p class="acceptance-text">
                By clicking "Join Room" you're accepting of 
                <a href="https://codely.fun/watchparty-policy" target="_blank">terms and policy</a>.
            </p>
        </div>
    </div>

    <div id="app" class="hidden">
        <div class="container">
            <div class="header">
                <h1><span id="headerTitle">üé¨ Watch Party</span></h1>
                <div class="room-info">
                    <div style="white-space: nowrap;">Room: <span id="roomIdDisplay"></span></div>
                    <div id="roomTimerDisplay" style="color: var(--color-timer-default);">Loading Timer...</div>
                </div>
            </div>
            
            <div class="main-content">
                <div class="video-call-section">
                    <div class="video-call-header">üìπ Video Call</div>
                    <div class="call-controls">
                        <button id="toggleVideoBtn" class="call-btn inactive">üì∑ Video Off</button>
                        <button id="toggleAudioBtn" class="call-btn inactive">üé§ Muted</button>
                    </div>
                    <div class="video-grid" id="videoGrid">
                        <div class="video-container">
                            <video id="localVideo" autoplay muted playsinline></video>
                            <div class="video-label" id="localVideoLabel">You</div>
                        </div>
                    </div>
                </div>

                <div class="video-section">
                    <div class="video-controls" id="videoControls">
                        <input type="text" id="videoUrlInput" placeholder="Paste YouTube URL here...">
                        <button id="loadVideoBtn">Load Video</button>
                    </div>
                    <video id="player" class="video-js vjs-default-skin" controls preload="auto" data-setup='{}'></video>
                </div>

                <div class="chat-section">
                    <div class="chat-header">
                        <h2>Chat</h2>
                        <div class="users-online" id="usersOnline"></div>
                    </div>
                    <div id="messages"></div>
                    <div class="chat-input">
                        <input type="text" id="messageInput" placeholder="Type a message...">
                        <button id="sendBtn">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="watermark">
        <a href="https://codely.fun/harshit_profile" target="_blank">
            Developed by Codely.fun (Harshit Singh)
        </a>
    </div>
    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/videojs-youtube@3.0.1/dist/Youtube.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-database-compat.min.js"></script>
    
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCXGPCCu9wLefW-Bn3kQ63rz9niHaVUogE",
            authDomain: "watch-party-f4623.firebaseapp.com",
            databaseURL: "https://watch-party-f4623-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "watch-party-f4623",
            storageBucket: "watch-party-f4623.firebasestorage.app",
            messagingSenderId: "432928189519",
            appId: "1:432928189519:web:0b4153ed3b236f7004ce3a"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let player;
        let roomId;
        let username;
        let userId;
        let isUpdating = false; 
        let isAdmin = false; 
        let currentAdminId = null; 
        
        // --- ROOM CLEANUP CONSTANTS AND VARIABLES ---
        const ROOM_LIFETIME_MS = 60 * 60 * 1000;      // 1 hour
        const CLEANUP_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes
        let roomExpirationTimer = null; // Timer reference for local room deletion
        let countdownInterval = null;   // NEW: Timer reference for visual countdown
        // ---------------------------------------------------

        // Map standard YouTube API states to constants for DB synchronization
        const PLAYER_STATE = {
            UNSTARTED: -1,
            ENDED: 0,
            PLAYING: 1,
            PAUSED: 2,
            BUFFERING: 3,
            CUED: 5 
        };

        // WebRTC Variables
        let localStream = null;
        let peerConnections = {};
        let videoEnabled = false;
        let audioEnabled = false;

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        // --- ROOM CLEANUP FUNCTIONS ---
        
        /**
         * Custom "alert" implementation to show a non-blocking message before reloading.
         */
        function showRoomExpiredMessage(message) {
            const expiredDiv = document.createElement('div');
            expiredDiv.id = 'expiredDiv'; // Add ID for checking if already displayed
            expiredDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(248, 113, 113, 0.95); color: white; z-index: 2000; 
                display: flex; justify-content: center; align-items: center; 
                flex-direction: column; font-size: 24px; text-align: center; padding: 20px;
                font-weight: bold;
            `;
            expiredDiv.innerHTML = `
                <div style="padding: 20px; border-radius: 10px; background: rgba(0,0,0,0.2);">
                    <p style="margin-bottom: 10px;">üî¥ Room Expired</p>
                    <p style="font-size: 18px;">${message}</p>
                    <p style="font-size: 14px; margin-top: 15px;">Reloading page in 4 seconds...</p>
                </div>
            `;
            document.body.appendChild(expiredDiv);

            // Reload the page after 4 seconds
            setTimeout(() => {
                window.location.reload();
            }, 4000); 
        }

        /**
         * Handles the event when the current room is deleted (either locally or by global sweep).
         */
        function handleRoomDeletion(message) {
            if (roomExpirationTimer) {
                clearTimeout(roomExpirationTimer);
                roomExpirationTimer = null;
            }
            
            // NEW: Clear visual countdown timer
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            // Use the custom message handler instead of alert()
            showRoomExpiredMessage(message);
        }
        
        /**
         * Deletes the current room from the database. Called when local expiration timer runs out.
         */
        function cleanupRoom() {
            if (!roomId) return;
            console.log(`Room ${roomId} has expired locally. Deleting...`);

            db.ref(`rooms/${roomId}`).remove()
                .then(() => {
                    handleRoomDeletion('Your room has expired (1 hour limit) and is being automatically deleted.');
                })
                .catch(error => {
                    console.error('Failed to delete room:', error);
                    handleRoomDeletion('An error occurred during room cleanup. Reloading.');
                });
        }

        /**
         * Schedules the local room expiration timer and starts the global cleanup sweep.
         */
        function scheduleRoomCleanup(createdTimestamp) {
            // Clear any existing timer
            if (roomExpirationTimer) {
                clearTimeout(roomExpirationTimer);
            }
            
            const now = Date.now();
            const expirationTime = createdTimestamp + ROOM_LIFETIME_MS;
            const timeToExpiration = expirationTime - now;

            if (timeToExpiration > 0) {
                const minutesLeft = Math.ceil(timeToExpiration / 60000);
                console.log(`Scheduling room deletion in ${minutesLeft} minutes.`);
                roomExpirationTimer = setTimeout(cleanupRoom, timeToExpiration);
            } else {
                // This case should be handled in joinRoom, but added for robustness
                cleanupRoom(); 
                return;
            }

            // Start the global cleanup sweep (run once immediately, then every 10 minutes)
            cleanupOldRooms();
            setInterval(cleanupOldRooms, CLEANUP_INTERVAL_MS);
        }

        /**
         * Scans all rooms and deletes any that are older than ROOM_LIFETIME_MS.
         */
        function cleanupOldRooms() {
            console.log('Running global room cleanup sweep...');
            const expirationThreshold = Date.now() - ROOM_LIFETIME_MS;

            db.ref('rooms').once('value', (snapshot) => {
                const rooms = snapshot.val();
                if (!rooms) return;

                Object.entries(rooms).forEach(([id, room]) => {
                    // Check if room has a 'created' timestamp and is older than the threshold
                    if (room.created && room.created < expirationThreshold) {
                        console.log(`üßπ Deleting expired room: ${id}`);
                        
                        db.ref(`rooms/${id}`).remove()
                            .catch(error => console.error(`Failed to delete expired room ${id}:`, error));
                        
                        // If the deleted room is the current room, the on('value') listener will handle it.
                    }
                });
            });
        }

        /**
         * Starts the room expiration countdown timer visible to the user.
         */
        function startCountdownTimer(createdTimestamp) {
            const timerDisplay = document.getElementById('roomTimerDisplay');
            const expirationTime = createdTimestamp + ROOM_LIFETIME_MS;

            // Clear any existing timer
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Function to run every second
            const updateTimer = () => {
                const now = Date.now();
                const timeRemainingMs = expirationTime - now;

                if (timeRemainingMs <= 0) {
                    timerDisplay.textContent = 'EXPIRED';
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    return;
                }

                const totalSeconds = Math.floor(timeRemainingMs / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                const format = (n) => String(n).padStart(2, '0');

                timerDisplay.textContent = `Expires in: ${format(hours)}:${format(minutes)}:${format(seconds)}`;
                
                // Change color to red when less than 5 minutes remain
                if (timeRemainingMs < 5 * 60 * 1000) {
                    timerDisplay.style.color = 'var(--color-alert-red)';
                } else {
                    timerDisplay.style.color = 'var(--color-timer-default)';
                }
            };
            
            updateTimer(); // Run immediately
            countdownInterval = setInterval(updateTimer, 1000);
        }
        // --- END: ROOM CLEANUP FUNCTIONS ---

        // NEW: Video.js Player Initialization
        function initializeVideoPlayer() {
            player = videojs('player', {
                controls: true,
                autoplay: false,
                techOrder: ['youtube', 'html5'], // Use youtube tech first
                sources: [],
                // --- START FIX: ADD YOUTUBE CONFIGURATION ---
                youtube: { 
                    iv_load_policy: 3, // Disable annotations
                    modestbranding: 1, // Cleaner player
                    enablejsapi: 1, // Ensure JS API is enabled for sync
                    origin: window.location.origin, // CRITICAL: Fixes cross-origin security check
                    rel: 0, // ADDED: No related videos at end
                    html5: 1 // ADDED: Explicitly use HTML5 player
                }
                // --- END FIX ---
            }, function() {
                console.log('Video.js player is ready');
                setupVideoListeners(this);
                syncWithRoom();
            });
        }
        
        // NEW: Setup Video.js Listeners
        function setupVideoListeners(playerInstance) {
            // Listeners for outgoing state changes (Admin role)
            
            // Play/Pause/End events only trigger database write if it was a user action (i.e., not isUpdating)
            playerInstance.on('play', function() { handlePlayerStateChange(PLAYER_STATE.PLAYING); });
            playerInstance.on('pause', function() { handlePlayerStateChange(PLAYER_STATE.PAUSED); });
            playerInstance.on('ended', function() { handlePlayerStateChange(PLAYER_STATE.ENDED); });
            
            // Time synchronization (to reduce database writes, only sync every 5 seconds while playing)
            playerInstance.on('timeupdate', function() {
                // Check if playing and time is roughly a multiple of 5 seconds (5, 10, 15...)
                if (!playerInstance.paused() && isAdmin && !isUpdating) {
                    const currentTime = playerInstance.currentTime();
                    if (Math.floor(currentTime * 10) % 50 === 0) { // Check every 5 seconds
                        handlePlayerStateChange(PLAYER_STATE.PLAYING);
                    }
                }
            });
        }

        // NEW: Handles outgoing state changes to Firebase (only for Admin)
        function handlePlayerStateChange(state) {
            if (isUpdating || !isAdmin) return;

            // Get videoId from the current source URL
            const videoId = getVideoIdFromUrl(player.currentSrc());

            const videoData = {
                state: state,
                time: player.currentTime(),
                videoId: videoId,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            // Only write if the state is a significant event and a video is loaded
            if (videoId && (state === PLAYER_STATE.PLAYING || state === PLAYER_STATE.PAUSED || state === PLAYER_STATE.ENDED)) {
                db.ref(`rooms/${roomId}/video`).set(videoData);
            }
        }


        function getVideoIdFromUrl(url) {
            // Extracts ID from YouTube URL formats
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function setAdmin(newAdminId) {
            if (newAdminId === currentAdminId) return;

            await db.ref(`rooms/${roomId}/adminId`).set(newAdminId);
            
            const newAdminName = (await db.ref(`rooms/${roomId}/users/${newAdminId}/name`).once('value')).val();
            sendSystemMessage(`${newAdminName} is now the Admin.`);
        }
        
        /**
         * Checks if the removed user was the admin and, if so, elects a new random admin.
         */
        async function electNewAdmin(removedUserId) {
            // Only proceed if the user who left was the current admin.
            if (removedUserId === currentAdminId) {
                
                // Fetch the remaining users
                const usersSnapshot = await db.ref(`rooms/${roomId}/users`).once('value');
                const remainingUsers = usersSnapshot.val();

                if (remainingUsers && Object.keys(remainingUsers).length > 0) {
                    const userIds = Object.keys(remainingUsers);
                    
                    // Randomly select one remaining user
                    const randomIndex = Math.floor(Math.random() * userIds.length);
                    const newAdminId = userIds[randomIndex];
                    
                    console.log(`Admin (${removedUserId}) left. Electing new admin: ${newAdminId}`);
                    
                    // Set the new admin (setAdmin updates the adminId node and sends a system message)
                    await setAdmin(newAdminId);
                    
                } else {
                    console.log(`Admin left, but no other users remain in room ${roomId}. Room is empty.`);
                    // Remove the adminId reference if the room is empty
                    db.ref(`rooms/${roomId}/adminId`).remove();
                }
            }
        }


        // WebRTC functions (omitted for brevity)
        async function initializeMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: true
                });
                
                localStream.getVideoTracks()[0].enabled = videoEnabled;
                localStream.getAudioTracks()[0].enabled = audioEnabled;

                document.getElementById('localVideo').srcObject = localStream;

                await db.ref(`rooms/${roomId}/peers/${userId}`).set({
                    name: username,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                });
                
                // Store user metadata
                await db.ref(`rooms/${roomId}/users/${userId}`).set({
                    name: username,
                    joined: firebase.database.ServerValue.TIMESTAMP
                });

                // Set disconnect handlers
                db.ref(`rooms/${roomId}/peers/${userId}`).onDisconnect().remove();
                db.ref(`rooms/${roomId}/users/${userId}`).onDisconnect().remove();

                setTimeout(() => setupPeerListeners(), 1000);

            } catch (error) {
                console.error('‚ùå Error accessing media:', error);
                // alert('Camera/microphone access denied. Video call will not work.'); // Replaced with console log
            }
        }

        function setupPeerListeners() {
            
            db.ref(`rooms/${roomId}/adminId`).on('value', (snapshot) => {
                currentAdminId = snapshot.val();
                updateAdminStatus();
            });
            
            // --- Attach room value listener to check for remote deletion ---
            db.ref(`rooms/${roomId}`).on('value', (snapshot) => {
                const roomData = snapshot.val();
                if (roomData === null && !document.getElementById('expiredDiv')) {
                    // Room no longer exists, and we haven't already shown the expiration message
                    handleRoomDeletion('Your room was deleted by a remote cleanup process because it expired.');
                }
            });
            // -------------------------------------------------------------------


            db.ref(`rooms/${roomId}/peers`).on('child_added', (snapshot) => {
                const peerId = snapshot.key;
                const peerData = snapshot.val();
                
                if (peerId !== userId && !peerConnections[peerId]) {
                    addRemoteVideo(peerId, new MediaStream(), peerData.name);
                    setTimeout(() => createPeerConnection(peerId, true), 500);
                }
            });

            db.ref(`rooms/${roomId}/peers`).on('child_removed', (snapshot) => {
                const peerId = snapshot.key;
                removePeerConnection(peerId);
            });

            db.ref(`rooms/${roomId}/signals/${userId}`).on('child_added', async (snapshot) => {
                const data = snapshot.val();
                const peerId = data.from;

                try {
                    if (data.type === 'offer') {
                        if (!peerConnections[peerId]) {
                            await createPeerConnection(peerId, false);
                            const peerData = (await db.ref(`rooms/${roomId}/users/${peerId}`).once('value')).val();
                            addRemoteVideo(peerId, new MediaStream(), peerData.name);
                        }
                        await peerConnections[peerId].setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await peerConnections[peerId].createAnswer();
                        await peerConnections[peerId].setLocalDescription(answer);
                        
                        await db.ref(`rooms/${roomId}/signals/${peerId}`).push({
                            from: userId,
                            type: 'answer',
                            answer: answer
                        });
                    } else if (data.type === 'answer') {
                        if (peerConnections[peerId]) {
                            await peerConnections[peerId].setRemoteDescription(new RTCSessionDescription(data.answer));
                        }
                    } else if (data.type === 'ice') {
                        if (peerConnections[peerId]) {
                            await peerConnections[peerId].addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                    }
                    snapshot.ref.remove();
                } catch (error) {
                    console.error('‚ùå Signal error:', error);
                }
            });
        }

        async function createPeerConnection(peerId, createOffer) {
            
            const pc = new RTCPeerConnection(configuration);
            peerConnections[peerId] = pc;

            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            let remoteStream = new MediaStream();
            
            pc.ontrack = (event) => {
                remoteStream.addTrack(event.track);
                
                const container = document.getElementById(`video-${peerId}`);
                let peerName = null;
                if (container) {
                    peerName = container.querySelector('.video-label').textContent;
                }
                
                addRemoteVideo(peerId, remoteStream, peerName); 
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    db.ref(`rooms/${roomId}/signals/${peerId}`).push({
                        from: userId,
                        type: 'ice',
                        candidate: event.candidate.toJSON()
                    });
                }
            };
            
            if (createOffer) {
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    await db.ref(`rooms/${roomId}/signals/${peerId}`).push({
                        from: userId,
                        type: 'offer',
                        offer: offer
                    });
                } catch (error) {
                    console.error('‚ùå Offer error:', error);
                }
            }

            return pc;
        }

        async function updateAdminStatus() {
            isAdmin = (userId === currentAdminId);

            const localLabel = document.getElementById('localVideoLabel');
            localLabel.innerHTML = 'You';
            if (isAdmin) {
                localLabel.innerHTML += '<span class="admin-tag">ADMIN</span>';
            }
            
            let adminName = 'Host';
            if (currentAdminId) {
                const snapshot = await db.ref(`rooms/${roomId}/users/${currentAdminId}/name`).once('value');
                adminName = snapshot.val() || 'Host';
            }
            
            document.getElementById('headerTitle').textContent = `üé¨ ${adminName}'s Watch Party`; 
            
            db.ref(`rooms/${roomId}/users`).once('value', (snapshot) => {
                updateUsersList(snapshot.val() || {});
            });

            const videoControls = document.getElementById('videoControls');
            if (isAdmin) {
                videoControls.style.display = 'flex';
            } else {
                videoControls.style.display = 'none';
            }
        }
        
        function addRemoteVideo(peerId, stream, peerName) {
            let container = document.getElementById(`video-${peerId}`);
            
            if (!container) {
                container = document.createElement('div');
                container.id = `video-${peerId}`;
                container.className = 'video-container';
                
                const video = document.createElement('video');
                video.autoplay = true;
                video.playsinline = true;
                video.srcObject = stream; 

                const label = document.createElement('div');
                label.className = 'video-label';
                label.textContent = peerName || 'Peer ' + peerId.substring(0, 6);
                
                // Add admin tag to the label if the peer is the current admin
                if (peerId === currentAdminId) {
                     label.innerHTML += '<span class="admin-tag">ADMIN</span>';
                }

                container.appendChild(video);
                container.appendChild(label);
                document.getElementById('videoGrid').appendChild(container);
            } else {
                const video = container.querySelector('video');
                if (video.srcObject !== stream) {
                    video.srcObject = stream;
                }
                
                // Update admin tag on existing video label
                const label = container.querySelector('.video-label');
                label.innerHTML = (peerName || 'Peer ' + peerId.substring(0, 6)) + (peerId === currentAdminId ? '<span class="admin-tag">ADMIN</span>' : '');
            }
        }

        function removePeerConnection(peerId) {
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
                delete peerConnections[peerId];
            }
            
            const elem = document.getElementById(`video-${peerId}`);
            if (elem) elem.remove();
        }

        function toggleVideo() {
            if (localStream) {
                videoEnabled = !videoEnabled;
                localStream.getVideoTracks()[0].enabled = videoEnabled;
                
                const btn = document.getElementById('toggleVideoBtn');
                btn.textContent = videoEnabled ? 'üì∑ Video On' : 'üì∑ Video Off';
                btn.className = videoEnabled ? 'call-btn active' : 'call-btn inactive';
            }
        }

        function toggleAudio() {
            if (localStream) {
                audioEnabled = !audioEnabled;
                localStream.getAudioTracks()[0].enabled = audioEnabled;
                
                const btn = document.getElementById('toggleAudioBtn');
                btn.textContent = audioEnabled ? 'üé§ Unmuted' : 'üé§ Muted';
                btn.className = audioEnabled ? 'call-btn active' : 'call-btn inactive';
            }
        }

        async function joinRoom() {
            // --- ROOM LIFECYCLE MANAGEMENT (Check and Set Creation Timestamp) ---
            const roomRef = db.ref(`rooms/${roomId}`);
            const roomSnapshot = await roomRef.once('value');
            const roomData = roomSnapshot.val();
            const now = Date.now();
            
            let roomCreatedTimestamp;

            if (roomData && roomData.created) {
                // Room exists, get the creation timestamp
                roomCreatedTimestamp = roomData.created;
                
                // Check if room has expired upon joining
                if (now - roomCreatedTimestamp > ROOM_LIFETIME_MS) {
                    console.log(`Room ${roomId} is already expired. Deleting now.`);
                    cleanupRoom();
                    return; // Exit join process
                }
            } else {
                // Room is new, set the creation timestamp to a server value placeholder
                await roomRef.update({ created: firebase.database.ServerValue.TIMESTAMP });
                
                // Fetch the newly written timestamp to accurately calculate expiration
                const newSnapshot = await roomRef.once('value');
                roomCreatedTimestamp = newSnapshot.val().created || now;
                
                console.log(`New room ${roomId} created at ${new Date(roomCreatedTimestamp).toLocaleString()}.`);
            }

            // Schedule cleanup based on the determined or new creation time
            scheduleRoomCleanup(roomCreatedTimestamp);
            // NEW: Start the visual countdown
            startCountdownTimer(roomCreatedTimestamp);
            // --- END: ROOM LIFECYCLE MANAGEMENT ---


            // Check/Set Admin when joining
            db.ref(`rooms/${roomId}/adminId`).once('value', (snapshot) => {
                if (!snapshot.exists() && isAdmin) {
                    setAdmin(userId);
                } else if (snapshot.exists()) {
                    currentAdminId = snapshot.val();
                    isAdmin = (userId === currentAdminId);
                }
                updateAdminStatus();
            });


            db.ref(`rooms/${roomId}/users`).on('value', (snapshot) => {
                updateUsersList(snapshot.val() || {});
            });
            
            // --- NEW LISTENER: Re-elect admin if a user is removed (e.g., disconnection) ---
            db.ref(`rooms/${roomId}/users`).on('child_removed', (snapshot) => {
                const removedUserId = snapshot.key;
                electNewAdmin(removedUserId);
            });
            // --------------------------------------------------------------------------------
            
            // Video player synchronization
            db.ref(`rooms/${roomId}/video`).on('value', (snapshot) => {
                const videoData = snapshot.val();
                if (videoData) updateVideo(videoData);
            });

            db.ref(`rooms/${roomId}/messages`).on('value', (snapshot) => {
                displayMessages(snapshot.val() || {});
            });

            sendSystemMessage(`${username} joined the room`);
            initializeMedia();
            
            // NEW: Initialize the Video.js player after joining
            initializeVideoPlayer();
        }

        function updateUsersList(users) {
            const container = document.getElementById('usersOnline');
            container.innerHTML = '';
            
            Object.entries(users).filter(([key, user]) => user.name).forEach(([userKey, user]) => {
                const entry = document.createElement('div');
                entry.className = 'user-entry';
                
                const badge = document.createElement('div');
                badge.className = 'user-badge';
                badge.textContent = user.name;
                
                if (userKey === currentAdminId) {
                    badge.innerHTML += '<span class="admin-tag">ADMIN</span>';
                }
                
                entry.appendChild(badge);
                
                if (isAdmin && userKey !== userId) {
                    const adminBtn = document.createElement('button');
                    adminBtn.className = 'admin-action-btn';
                    adminBtn.textContent = 'Make Admin';
                    adminBtn.onclick = () => setAdmin(userKey);
                    entry.appendChild(adminBtn);
                }
                
                container.appendChild(entry);
            });
        }

        /**
         * The core synchronization function. Rewritten for Video.js.
         */
        function updateVideo(videoData) {
            if (!player || player.isDisposed()) return;

            // CRITICAL: Immediately block local events from interfering with remote command
            isUpdating = true; 

            try {
                const currentVideoId = getVideoIdFromUrl(player.currentSrc());
                const targetVideoId = videoData.videoId;

                // 1. Load video if ID is new or player is uninitialized
                if (targetVideoId && targetVideoId !== currentVideoId) {
                    
                    const newSource = {
                        type: 'video/youtube',
                        src: `https://www.youtube.com/watch?v=${targetVideoId}`
                    };
                    
                    // Set the new video source. Video.js will handle the load.
                    player.src(newSource);
                    
                    // After loading the source, we fall through to step 2 to set the time/state.
                } 
                
                // 2. Sync State and Time
                
                // Time Sync: Seek only if difference is significant and player is ready
                if (player.readyState() >= 1) { // readyState >= 1 means metadata loaded
                    const playerTime = player.currentTime() || 0;
                    const timeDiff = Math.abs(playerTime - videoData.time);

                    if (timeDiff > 2) { 
                        player.currentTime(videoData.time);
                    }
                }

                // State Sync: Apply play/pause command explicitly
                if (videoData.state === PLAYER_STATE.PLAYING && player.paused()) {
                    // This command is critical for remote play.
                    player.play().catch(e => {
                        console.warn("Autoplay was blocked by browser. User must click play.", e);
                        // This warning is normal for browsers with strict autoplay policies.
                    });
                } else if (videoData.state === PLAYER_STATE.PAUSED && !player.paused()) {
                    player.pause();
                }
                
            } catch (error) {
                console.error('Video.js Update error:', error);
            }

            // CRITICAL: Clear the flag after a short delay to allow the player to settle/process its own events
            setTimeout(() => { isUpdating = false; }, 500);
        }

        function syncWithRoom() {
            db.ref(`rooms/${roomId}/video`).once('value', (snapshot) => {
                const videoData = snapshot.val();
                if (videoData) updateVideo(videoData);
            });
        }


        function extractVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message) {
                db.ref(`rooms/${roomId}/messages`).push({
                    user: username,
                    userId: userId,
                    text: message,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
                input.value = '';
            }
        }

        function sendSystemMessage(text) {
            db.ref(`rooms/${roomId}/messages`).push({
                system: true,
                text: text,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
        }

        function displayMessages(messages) {
            const container = document.getElementById('messages');
            container.innerHTML = '';
            
            Object.values(messages).sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0)).forEach(msg => {
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message';
                
                if (msg.system) {
                    msgDiv.innerHTML = `<div class="message-system">${msg.text}</div>`;
                } else {
                    msgDiv.innerHTML = `
                        <div class="message-user">${msg.user}</div>
                        <div class="message-text">${msg.text}</div>
                    `;
                }
                
                container.appendChild(msgDiv);
            });
            
            container.scrollTop = container.scrollHeight;
        }

        // Event Listeners
        function setupEventListeners() {
            document.getElementById('joinBtn').addEventListener('click', () => {
                username = document.getElementById('usernameInput').value.trim();
                let inputRoomId = document.getElementById('roomIdInput').value.trim();

                if (!username) {
                    // Replaced alert() with console error/log
                    console.error('Please enter your name');
                    return;
                }
                
                if (!inputRoomId) {
                    roomId = generateRoomId();
                    isAdmin = true;
                } else {
                    roomId = inputRoomId;
                }

                userId = Date.now().toString();

                document.getElementById('setupModal').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('roomIdDisplay').textContent = roomId;
                
                joinRoom();
            });

            // The load button now only writes the desired state (PLAYING) to Firebase
            document.getElementById('loadVideoBtn').addEventListener('click', () => {
                if (!isAdmin) {
                    // Replaced alert() with console error/log
                    console.error('Only the room admin can load videos.');
                    return;
                }
                
                const url = document.getElementById('videoUrlInput').value;
                const videoId = extractVideoId(url);
                
                if (videoId) {
                    // Write the new video information and initial state (PLAYING) directly to Firebase
                    db.ref(`rooms/${roomId}/video`).set({
                        state: PLAYER_STATE.PLAYING,
                        time: 0, 
                        videoId: videoId,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    sendSystemMessage(`${username} loaded a new video`);
                    
                    document.getElementById('videoUrlInput').value = '';
                } else {
                    // Replaced alert() with console error/log
                    console.error('Invalid YouTube URL');
                }
            });

            document.getElementById('toggleVideoBtn').addEventListener('click', toggleVideo);
            document.getElementById('toggleAudioBtn').addEventListener('click', toggleAudio);

            document.getElementById('sendBtn').addEventListener('click', sendMessage);
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
            
            document.getElementById('videoControls').style.display = 'none';
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupEventListeners);
        } else {
            setupEventListeners();
        }
    </script>
</body>
</html>
